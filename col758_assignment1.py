# -*- coding: utf-8 -*-
"""COL758_Assignment1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yCZRpkI0qTc_y5QiK3hDHXC3auqGEhth
"""

#importing the networkx library
import networkx as nx
#importing the matplotlib library for plotting the graph
import matplotlib.pyplot as plt
import numpy as np
import random
import math
import csv
from math import e
from collections import deque
from sklearn.metrics import mean_squared_error
from numpy.random import choice

# Generates random graph with n vertices. An edge is chosen with a probability p
def RandomGraphGenerator(n, p):
  edges = []
  for i in range(n):
    for j in range(n):
      if i == j: continue
      if random.uniform(0, 1) <= p:
        edges.append((i,j))
  graph = nx.DiGraph()
  # G = nx.erdos_renyi_graph(n, p)
  graph.add_edges_from(edges)
  return graph

def RandomizedTransitiveClosure(graph, epsilon, n, choice_of_estimator):
  edges = graph.edges
  reverse_edges = []
  for edge in edges:
    reverse_edges.append((edge[1], edge[0]))
  adj = []
  for i in range(n):
    adj.append([])
  for edge in reverse_edges:
    u = edge[0]
    v = edge[1]
    adj[u].append(v)
  k = int(math.log(n)/epsilon)
  w = np.zeros((n, k))
  for i in range(k):
    # Assign to each v âˆˆ V a uniformly independent random label from [0, 1]
    labels = [(v, random.uniform(0,1)) for v in range(n)]
    labels.sort(key = lambda x: x[1])
    visited = np.zeros(n)
    # Performing BFS to store label of smallest label vertex reachable from
    # a vertex v
    for entry in labels:
      vertex = entry[0]
      val = entry[1]
      if visited[vertex] == 1: continue
      visited[vertex] = 1
      w[vertex][i] = val
      current = [vertex]
      while current:
        nxt = []
        for u in current:
          for v in adj[u]:
            if visited[v] == 1: continue
            visited[v] = 1
            nxt.append(v)
            w[v][i] = val
        current = nxt
  # Sorting the 2-D array (n*k) along rows in decreasing order
  # this is done to access the (k/e)th largest element from the
  # k values in w[v] array
  w = np.sort(-w,axis=1)*-1
  p = []
  for v in range(n):
    if choice_of_estimator == 0:
      x = w[v][int(k/e)]
      p.append(int(1/x))
    else:
      x = w[v].sum()/k
      p.append(int(1/x))
  return p

def TransitiveClosure(graph, n):
  edges = graph.edges
  adj = []
  for i in range(n):
    adj.append([])
  for edge in edges:
    u = edge[0]
    v = edge[1]
    adj[u].append(v)
  tc = np.zeros((n, n), int)
  for i in range(n):
    # start BFS from vertex i
    q = deque()
    q.append(i);
    while len(q) != 0:
      # pop out the front element
      fr = q.popleft()
      tc[i][fr] = 1
      for adjVert in adj[fr]:
        if tc[i][adjVert] != 1:
          tc[i][adjVert] = 1
          q.append(adjVert)
  return np.sum(tc, axis = 1)

# We measure the number of vertices whose estimated size
# of reachability set is within (1-epsilon) to (1+epsilon)
# of the actual size
def AccuracyScore(tc, p, epsilon, n):
  count = 0
  for i in range(n):
    estimate = p[i]
    actual = tc[i]
    lower_bound = (1 - epsilon) * actual
    upper_bound = (1 + epsilon) * actual
    if estimate >= lower_bound and estimate <= upper_bound:
      count = count + 1
  return count/n

def RealWorld(inputNum):
  edges = []
  strInput = open('/content/input_' + str(inputNum) + '.txt','r')
  ln = strInput.readline()
  lnList = ln.split()
  n = int(lnList[0])
  nEdges = int(lnList[1])
  for i in range(nEdges):
    ln = strInput.readline()
    lnList = ln.split()
    edges.append((int(lnList[0]), int(lnList[1])))

  graph = nx.DiGraph()
  graph.add_edges_from(edges)
  return (n, graph)

noTest = 5
# n is count of nodes, G corresponding vertex
n_inp = [None]*noTest
Gr = [None]*noTest

for i in range(noTest):
  (n_inp[i], Gr[i]) = RealWorld(i)

epsilons = [0.001, 0.05, 0.1]
p1_obs1 = []
p1_obs2 = []
for epsilon in epsilons:
  mean_squared_acc = []
  epsilon_acc = []
  for i in range(noTest):
    n = n_inp[i]
    G = Gr[i]
    tc = TransitiveClosure(G, n)
    P = RandomizedTransitiveClosure(G, epsilon, n, 0)
    mean_squared_acc.append(mean_squared_error(tc,P))
    epsilon_acc.append(AccuracyScore(tc,P,epsilon,n))
  p1_obs1.append(mean_squared_acc)
  p1_obs2.append(epsilon_acc)

# part 2
# as a function of n
epsilons = [0.001, 0.05, 0.1]
obs1 = []
obs2 = []
n_input = [10, 20, 30, 40, 50, 100, 200, 400, 800, 1000]
for epsilon in epsilons:
  mean_squared_acc = []
  epsilon_acc = []
  for n in n_input:
    p = 1/n
    G = RandomGraphGenerator(n, p)
    tc = TransitiveClosure(G, n)
    P = RandomizedTransitiveClosure(G, epsilon*epsilon, n, 0)
    mean_squared_acc.append(mean_squared_error(tc,P))
    epsilon_acc.append(AccuracyScore(tc,P,epsilon,n))
  obs1.append(mean_squared_acc)
  obs2.append(epsilon_acc)

plt.plot(n_input, obs1[0], label = "epsilon = 0.001")
plt.plot(n_input, obs1[1], label = "epsilon = 0.05")
# plt.plot(n_input, obs1[2], label = "epsilon = 0.1")
plt.xlabel('number of node (n)')
plt.ylabel('mean_squared_error')
plt.legend()
plt.show()

plt.plot(n_input, obs2[0], label = "epsilon = 0.001")
plt.plot(n_input, obs2[1], label = "epsilon = 0.05")
# plt.plot(n_input, obs2[2], label = "epsilon = 0.1")
plt.xlabel('number of node (n)')
plt.ylabel('epsilon_accuracy')
plt.legend()
plt.show()

epsilon = 0.1
prob_obs1 = []
prob_obs2 = []
prob_x = []
# n_input = [50, 100, 200]
n_input = [1000]
for n in n_input:
  mean_squared_acc = []
  epsilon_acc = []
  x_axis = []
  p = 0.0008
  while p <= 0.1:
    x_axis.append(p)
    G = RandomGraphGenerator(n, p)
    print(len(G.edges))
    tc = TransitiveClosure(G, n)
    P = RandomizedTransitiveClosure(G, epsilon*epsilon, n, 0)
    mean_squared_acc.append(mean_squared_error(tc,P))
    epsilon_acc.append(AccuracyScore(tc,P,epsilon,n))
    p = p*2
  prob_obs1.append(mean_squared_acc)
  prob_obs2.append(epsilon_acc)
  prob_x.append(x_axis)

plt.plot(prob_x[0], prob_obs2[0], label = "n = 200")
# plt.plot(prob_x[1], prob_obs2[1], label = "n = 100")
# plt.plot(prob_x[2], prob_obs2[2], label = "n = 200")
plt.xlabel('probability (p)')
plt.ylabel('epsilon_accuracy')
plt.legend()
plt.xlim([0.0007, 0.01])
plt.show()
print(prob_obs2[0])

plt.plot(prob_x[0], prob_obs1[0], label = "n = 200")
# plt.plot(prob_x[1], prob_obs1[1], label = "n = 100")
# plt.plot(prob_x[2], prob_obs1[2], label = "n = 200")
plt.xlabel('probability (p)')
plt.ylabel('mean_squared_error')
plt.legend()
plt.show()

# part 3
n_input = [10, 20, 30, 40, 50, 100, 200, 400, 800, 1000]
epsilons = [0.001, 0.05, 0.1]
p3_obv1 = []
p3_obv2 = []

for epsilon in epsilons:
  mean_squared_acc = []
  epsilon_acc = []
  for i in range(len(n_inp)):
    n = n_inp[i]
    edges = []
    for j in range(n-1):
        edges.append((j, j+1))
    graph = nx.DiGraph()
    graph.add_edges_from(edges)
    tc = TransitiveClosure(graph, n)
    P = RandomizedTransitiveClosure(graph, epsilon, n, 0)
    mean_squared_acc.append(mean_squared_error(tc,P))
    epsilon_acc.append(AccuracyScore(tc,P,epsilon,n))
  p3_obv1.append(mean_squared_acc)
  p3_obv2.append(epsilon_acc)

plt.plot(n_inp, p3_obv1[0], label = "epsilon = 0.001")
plt.plot(n_inp, p3_obv1[1], label = "epsilon = 0.05")
plt.plot(n_inp, p3_obv1[2], label = "epsilon = 0.1")
plt.xlabel('number of nodes (n)')
plt.ylabel('mean_squared_error')
plt.legend()
plt.show()

plt.plot(n_inp, p3_obv2[0], label = "epsilon = 0.001")
plt.plot(n_inp, p3_obv2[1], label = "epsilon = 0.05")
plt.plot(n_inp, p3_obv2[2], label = "epsilon = 0.1")
plt.xlabel('number of nodes (n)')
plt.ylabel('epsilon_accuracy')
plt.legend()
plt.show()

epsilon = 0.1
n_ip = [50, 60, 80, 100, 200]
tc_ip = []
P_ip = []
for i in range(len(n_ip)):
  n = n_ip[i]
  edges = []
  for j in range(n-1):
      edges.append((j, j+1))
  graph = nx.DiGraph()
  graph.add_edges_from(edges)
  tc = TransitiveClosure(graph, n)
  P = RandomizedTransitiveClosure(graph, epsilon*epsilon, n, 0)
  tc_ip.append(tc)
  P_ip.append(P)

acc = []
for i in range(len(n_ip)):
  cor = 0
  for j in range(n_ip[i]):
    if(P_ip[i][j]/tc_ip[i][j] <= 1.1 and P_ip[i][j]/tc_ip[i][j] >= 0.9): 
      cor = cor+1
  acc.append(cor/n_ip[i])

plt.plot(n_ip, acc, label = "epsilon = 0.1")
plt.xlabel('number of nodes (n)')
plt.ylabel('epsilon_accuracy')
plt.legend()
plt.show()

bad_n = []
for i in range(len(n_ip)):
  invalid = -1
  for j in range(n_ip[i]):
    if(P_ip[i][j]/tc_ip[i][j] <= 1.1 and P_ip[i][j]/tc_ip[i][j] >= 0.9): 
      if(invalid == -1): invalid = j+1
  bad_n.append(invalid)

plt.plot(n_ip, bad_n, label = "epsilon = 0.1")
plt.xlabel('number of nodes (n)')
plt.ylabel('First Vertex Out of Bound')
plt.legend()
plt.show()

G_random = RandomGraphGenerator(100, 0.1)
tc = TransitiveClosure(G_random, 100)
print(tc)

# part 4
epsilon = 0.05
n_inp = [10, 20, 30, 40, 50, 100, 200, 400, 800, 1000]
mean_squared_acc_1 = []
epsilon_acc_1 = []
mean_squared_acc_2 = []
epsilon_acc_2 = []
tc_all = []
P1_all = []
P2_all = []
for n in n_inp:
  p = 1/n
  G = RandomGraphGenerator(n, p)
  tc = TransitiveClosure(G, n)
  P1 = RandomizedTransitiveClosure(G, epsilon, n, 0)
  P2 = RandomizedTransitiveClosure(G, epsilon, n, 1)
  tc_all.append(tc)
  P1_all.append(P1)
  P2_all.append(P2)
  mean_squared_acc_1.append(mean_squared_error(tc,P1))
  mean_squared_acc_2.append(mean_squared_error(tc,P2))
  epsilon_acc_1.append(AccuracyScore(tc, P1, epsilon, n))
  epsilon_acc_2.append(AccuracyScore(tc, P2, epsilon, n))

plt.plot(n_inp, mean_squared_acc_1, label = "E1")
plt.plot(n_inp, mean_squared_acc_2, label = "E2")
plt.xlabel('number of nodes (n)')
plt.ylabel('mean_squared_error')
plt.legend()
plt.show()

plt.plot(n_inp, epsilon_acc_1, label = "E1")
plt.plot(n_inp, epsilon_acc_2, label = "E2")
plt.xlabel('number of nodes (n)')
plt.ylabel('epsilon_accuracy')
plt.legend()
plt.show()

i = 0
X_axis = np.arange(n_inp[i])
plt.bar(X_axis - 0.25, tc_all[i], 0.25, label = 'Deterministic Size')
plt.bar(X_axis + 0, P1_all[i], 0.25, label = 'E1 Size')
plt.bar(X_axis + 0.25, P2_all[i], 0.25, label = 'E2 Size')
plt.xlabel("Vertex Number")
plt.ylabel("Transitive Closure Size")
plt.legend()
plt.show()

i = 9
error_i = []
for j in range(n_inp[i]):
  error_i.append(abs(P1_all[i][j]/tc_all[i][j]))
plt.hist(error_i,bins = 75, label='E1')
plt.xlim([0.6, 1.6])
plt.legend()
plt.show()

i = 9
error_i = []
for j in range(n_inp[i]):
  error_i.append(abs(P2_all[i][j]/tc_all[i][j]))
plt.hist(error_i,bins = 75, label='E2')
plt.xlim([0.6, 1.6])
plt.legend()
plt.show()
